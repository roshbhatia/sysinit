#!/usr/bin/env bash
# THIS FILE WAS INSTALLED BY SYSINIT. MODIFICATIONS WILL BE OVERWRITTEN UPON UPDATE.
# shellcheck disable=all

help() {
    echo "Usage: $(basename "$0") [options]"
    echo
    echo "Generate a conventional commit message using GitHub Copilot"
    echo
    echo "Options:"
    echo "  -c, --context TEXT        Additional context for the commit message"
    echo "  -s, --ci-skip            Add [ci skip] to the commit scope"
    echo "  -b, --breaking-change    Mark this as a breaking change"
    echo "  -i, --interactive        Enable interactive mode with gum"
    echo "  -h, --help              Show this help message"
    exit 0
}

validate_context() {
    if [[ -z "$2" ]]; then
        echo "Error: --context requires a value"
        exit 1
    fi
}

if [[ $# -eq 0 ]]; then
    help
fi

command -v gum >/dev/null 2>&1 || { echo "Error: gum is required for interactive mode. Install with 'brew install gum'"; exit 1; }
eval "$(gh copilot alias bash)"

CI_SKIP=${CI_SKIP:-false}
BREAKING_CHANGE=${BREAKING_CHANGE:-false}
INTERACTIVE=${INTERACTIVE:-false}

while [[ $# -gt 0 ]]; do
    case $1 in
        -h|--help)
            help
            ;;
        -c|--context)
            validate_context "$@"
            CONTEXT="$2"
            shift 2
            ;;
        -s|--ci-skip)
            CI_SKIP=true
            shift
            ;;
        -b|--breaking-change)
            BREAKING_CHANGE=true
            shift
            ;;
        -i|--interactive)
            INTERACTIVE=true
            shift
            ;;
        *)
            echo "Error: Unknown option: $1"
            echo "Use --help to see available options"
            exit 1
            ;;
    esac
done

# Validate git repository
if ! git rev-parse --is-inside-work-tree >/dev/null 2>&1; then
    echo "Error: Not in a git repository"
    exit 1
fi

# Check for staged changes
if [[ -z "$(git diff --staged)" ]]; then
    echo "Error: No staged changes found. Stage your changes with 'git add' first"
    exit 1
fi

# Get branch name without origin/ prefix
BRANCH_NAME=$(git rev-parse --abbrev-ref HEAD 2>/dev/null || echo "unknown")

# Get staged files diff, truncated to first 500 chars
STAGED_DIFF=$(git diff --cached --unified=0 2>/dev/null | head -c 500 || echo "No diff available")

# Build the prompt for copilot
read -r -d '' SCHEMA << EOF
{
  "type": "object",
  "required": ["type", "subject"],
  "properties": {
    "type": {
      "type": "string",
      "enum": ["fix", "feat", "chore", "docs"]
    },
    "scope": {
      "type": "string"
    },
    "subject": {
      "type": "string",
      "maxLength": 72
    },
    "body": {
      "type": "string",
      "maxLength": 500
    },
    "files": {
      "type": "object",
      "additionalProperties": {
        "type": "string"
      }
    },
    "breaking": {
      "type": "boolean"
    }
  }
}
EOF

STAGED_FILES=$(git diff --cached --name-only 2>/dev/null)
FILES_JSON="{"
if [[ -n "$STAGED_FILES" ]]; then
    while IFS= read -r file; do
        if [[ -n "$file" ]]; then
            FULL_PATH=$(git rev-parse --show-toplevel 2>/dev/null)/$file
            DESC=$(git diff --cached "$file" 2>/dev/null | head -n 50 | gh copilot suggest "Summarize this change in 10 words or less" || echo "Changed file")
            # Escape quotes and sanitize the JSON
            FULL_PATH=$(echo "$FULL_PATH" | sed 's/"/\\"/g')
            DESC=$(echo "$DESC" | sed 's/"/\\"/g')
            FILES_JSON+="\"$FULL_PATH\": \"$DESC\","
        fi
    done <<< "$STAGED_FILES"
    FILES_JSON="${FILES_JSON%,}" # Remove trailing comma
fi
FILES_JSON+="}"

read -r -d '' PROMPT << EOF
Create a conventional commit message based on the following info:
Branch name: ${BRANCH_NAME}
Staged changes:
${STAGED_DIFF}

${CONTEXT:+Additional context: ${CONTEXT}

}Schema for the response - output MUST be valid JSON:
${SCHEMA}

A few rules:
1. Type must be one of: fix, feat, chore, docs
2. Subject must be under 72 chars
3. If ci-skip is ${CI_SKIP:-false}, include "[ci skip]" in scope
4. If breaking-change is ${BREAKING_CHANGE:-false}, set breaking to true
5. Files field should be: ${FILES_JSON}

Please output ONLY valid JSON matching the schema above.
EOF

# Run copilot suggest and store output
COMMIT_MSG=$(ghcs "${PROMPT}" 2>/dev/null | jq --arg ci_skip "$CI_SKIP" -c 'if .type and .subject then 
  . + {
    message: (
      .type + 
      (if .scope then 
        "(" + .scope + (if $ci_skip == "true" then "[ci skip]" else "" end) + ")" 
      else 
        (if $ci_skip == "true" then "([ci skip])" else "" end)
      end) +
      (if .breaking then "!" else "" end) + 
      ": " + .subject + 
      (if .body then "\n\n" + .body else "" end)
    )
  } 
else . end' 2>/dev/null)

# Check if we got a valid commit message
if [[ -z "$COMMIT_MSG" ]] || [[ "$COMMIT_MSG" == "null" ]]; then
    echo "Error: Failed to generate commit message. Please try again."
    exit 1
fi

# Extract just the message field if it exists
COMMIT_MSG=$(echo "$COMMIT_MSG" | jq -r '.message // .' 2>/dev/null || echo "$COMMIT_MSG")

if [[ $INTERACTIVE == "true" ]]; then
    echo "Generated commit message:"
    echo "$COMMIT_MSG"
    echo
    EDITED_MSG=$(echo "$COMMIT_MSG" | gum write --width 80 --placeholder "Edit commit message...")
    if [[ -z "$EDITED_MSG" ]]; then
        echo "Error: Empty commit message. Aborting."
        exit 1
    fi
    if gum confirm "Use this commit message?"; then
        echo "$EDITED_MSG"
    else
        exit 1
    fi
else
    if [[ -n "$COMMIT_MSG" ]]; then
        echo "$COMMIT_MSG"
    else
        echo "Error: Failed to generate commit message"
        exit 1
    fi
fi
