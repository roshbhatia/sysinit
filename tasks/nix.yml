# yaml-language-server: $schema=https://taskfile.dev/schema.json
version: "3"

tasks:
  clean-results:
    desc: Clean up result symlinks (internal helper)
    internal: true
    cmds:
      - sudo rm -f result result-* 2>/dev/null || true
    silent: true

  build:
    desc: Build the system configuration without applying
    silent: true
    deps: [clean-results]
    cmds:
      - |
        #!/usr/bin/env bash
        set -euo pipefail
        source {{.LOGLIB_PATH}}

        log_info "Building system configuration"
        if ! NIXPKGS_ALLOW_UNFREE={{.NIXPKGS_ALLOW_UNFREE}} sudo -E {{.NIX_DARWIN_REBUILD}} build -v --flake . --impure; then
          log_error "Build failed (see logs above)"
          exit {{.ERROR_EXIT_CODE}}
        fi

        log_success "Build completed successfully"
      - task: clean-results

  clean:
    desc: Clean Nix store and delete old generations
    silent: true
    deps: [clean-results]
    cmds:
      - |
        #!/usr/bin/env bash
        set -euo pipefail
        source {{.LOGLIB_PATH}}

        log_info "Collecting garbage and deleting old generations"
        nix-collect-garbage -d

        log_info "Optimizing Nix store (deduplicating files)"
        nix-store --optimise

        log_success "Nix store cleaned and optimized"

  update:
    desc: Update Nix flake inputs and commit lock file
    silent: true
    cmds:
      - |
        #!/usr/bin/env bash
        set -euo pipefail
        source {{.LOGLIB_PATH}}
        log_info "Updating nix flake inputs"

        if ! nix flake update; then
          log_error "Flake update failed (see logs above)"
          exit {{.ERROR_EXIT_CODE}}
        fi

        if git diff --quiet flake.lock; then
          log_info "No changes to flake.lock"
        else
          git add flake.lock
          git commit -m "flake.lock: Update"
          log_info "Committed flake.lock changes"
        fi

        log_success "Flake inputs updated successfully"

  config:
    desc: Copy nix configs (custom and secrets) to /etc/nix/ with sudo
    silent: true
    cmds:
      - |
        #!/usr/bin/env bash
        set -euo pipefail
        source {{.LOGLIB_PATH}}

        log_info "Updating nix configuration"

        # Copy custom config
        if ! sudo cp nix.custom.conf /etc/nix/nix.custom.conf; then
          log_error "Failed to copy nix.custom.conf"
          exit {{.ERROR_EXIT_CODE}}
        fi

        # Copy secrets if they exist
        if [ -f "nix.secrets.conf" ]; then
          if ! sudo cp nix.secrets.conf /etc/nix/nix.secrets.conf; then
            log_error "Failed to copy nix.secrets.conf"
            exit {{.ERROR_EXIT_CODE}}
          fi
          sudo chmod 600 /etc/nix/nix.secrets.conf
          log_info "Deployed nix.secrets.conf with restrictive permissions"
        else
          log_warn "nix.secrets.conf not found (run 'task nix:secrets:init' to create)"
        fi

        log_info "Restarting nix-daemon"
        if ! sudo launchctl kickstart -k system/org.nixos.nix-daemon; then
          log_error "Failed to restart nix-daemon"
          exit {{.ERROR_EXIT_CODE}}
        fi

        log_success "Nix configuration updated successfully"

  secrets:init:
    desc: Initialize nix.secrets.conf with GitHub token (automatic, idempotent)
    silent: true
    cmds:
      - |
        #!/usr/bin/env bash
        set -euo pipefail
        source {{.LOGLIB_PATH}}

        SECRETS_FILE="{{.ROOT_DIR}}/nix.secrets.conf"
        SYSTEM_SECRETS_FILE="{{.NIX_SYSTEM_CONF_DIR}}/nix.secrets.conf"

        # Function to check if secrets file is valid
        is_secrets_file_valid() {
          [ -f "$1" ] && grep -q '^[^#]*access-tokens[[:space:]]*=' "$1"
        }

        # Function to create secrets file with token
        create_secrets_file() {
          local token="$1"
          {
            echo "# Nix secrets configuration"
            echo "# GitHub Personal Access Token for private repository access"
            echo "access-tokens = github.com=${token}"
          } > "${SECRETS_FILE}"
          chmod 600 "${SECRETS_FILE}"
        }

        # Function to deploy secrets to system
        deploy_secrets() {
          log_info "Deploying secrets to ${SYSTEM_SECRETS_FILE}"
          if ! sudo cp "${SECRETS_FILE}" "${SYSTEM_SECRETS_FILE}"; then
            log_error "Failed to copy secrets to system directory"
            return 1
          fi
          sudo chmod 600 "${SYSTEM_SECRETS_FILE}"

          log_info "Restarting nix-daemon"
          if ! sudo launchctl kickstart -k system/org.nixos.nix-daemon; then
            log_error "Failed to restart nix-daemon"
            return 1
          fi
          return 0
        }

        log_info "Initializing nix secrets configuration"

        # Check if valid secrets file already exists
        if is_secrets_file_valid "${SECRETS_FILE}"; then
          log_success "Valid nix.secrets.conf already exists"

          # Ensure it's deployed to system (use sudo for reading system file)
          if [ ! -f "${SYSTEM_SECRETS_FILE}" ] || ! sudo grep -q '^[^#]*access-tokens[[:space:]]*=' "${SYSTEM_SECRETS_FILE}" 2>/dev/null; then
            if deploy_secrets; then
              log_success "Secrets deployed to system"
            fi
          else
            log_info "Secrets already deployed to system"
          fi
          exit 0
        fi

        # Try to get token from gh CLI
        log_info "Attempting to get GitHub token from gh CLI"
        if command -v gh >/dev/null 2>&1; then
          if GITHUB_TOKEN=$(gh auth token 2>/dev/null); then
            log_success "Retrieved token from gh CLI"
            create_secrets_file "${GITHUB_TOKEN}"

            if deploy_secrets; then
              log_success "Secrets initialized and deployed successfully"
              exit 0
            else
              exit {{.ERROR_EXIT_CODE}}
            fi
          else
            log_warn "gh CLI is installed but not authenticated"
            log_info "Run 'gh auth login' to authenticate, then re-run this task"
          fi
        else
          log_warn "gh CLI not found in PATH"
          log_info "Authenticate with gh CLI: gh auth login"
        fi

        # If we get here, we couldn't auto-configure
        log_warn "Could not automatically configure GitHub authentication"
        exit 0

  secrets:check:
    desc: Check if nix.secrets.conf exists and is properly configured (read-only)
    silent: true
    cmds:
      - |
        #!/usr/bin/env bash
        set -euo pipefail
        source {{.LOGLIB_PATH}}

        SECRETS_FILE="{{.ROOT_DIR}}/nix.secrets.conf"
        SYSTEM_SECRETS_FILE="{{.NIX_SYSTEM_CONF_DIR}}/nix.secrets.conf"

        # Function to check if secrets file is valid
        is_secrets_file_valid() {
          [ -f "$1" ] && grep -q '^[^#]*access-tokens[[:space:]]*=' "$1"
        }

        log_info "Checking nix secrets configuration"
        ISSUES=0

        # Check repository file
        if ! is_secrets_file_valid "${SECRETS_FILE}"; then
          log_error "nix.secrets.conf not found or invalid in repository root"
          ISSUES=$((ISSUES + 1))
        else
          # Check permissions (support both GNU and BSD stat)
          if [ -f "${SECRETS_FILE}" ]; then
            PERMS=$(stat -c %a "${SECRETS_FILE}" 2>/dev/null || stat -f "%Lp" "${SECRETS_FILE}" 2>/dev/null || echo "000")
            if [ "${PERMS}" != "600" ]; then
              log_warn "Incorrect permissions on nix.secrets.conf: ${PERMS} (should be 600)"
              ISSUES=$((ISSUES + 1))
            fi
          fi
        fi

        # Check system deployment (use sudo for reading root-owned file)
        if [ ! -f "${SYSTEM_SECRETS_FILE}" ] || ! sudo grep -q '^[^#]*access-tokens[[:space:]]*=' "${SYSTEM_SECRETS_FILE}" 2>/dev/null; then
          log_error "Secrets not deployed to ${SYSTEM_SECRETS_FILE}"
          ISSUES=$((ISSUES + 1))
        else
          PERMS=$(sudo stat -c %a "${SYSTEM_SECRETS_FILE}" 2>/dev/null || sudo stat -f "%Lp" "${SYSTEM_SECRETS_FILE}" 2>/dev/null || echo "000")
          if [ "${PERMS}" != "600" ]; then
            log_warn "Incorrect permissions on system secrets: ${PERMS} (should be 600)"
            ISSUES=$((ISSUES + 1))
          fi
        fi

        # Check gh CLI auth status (informational only)
        if command -v gh >/dev/null 2>&1; then
          if gh auth token >/dev/null 2>&1; then
            log_info "gh CLI is authenticated"
          else
            log_info "gh CLI is installed but not authenticated"
          fi
        else
          log_info "gh CLI not found in PATH"
        fi

        # Report results
        if [ ${ISSUES} -eq 0 ]; then
          log_success "Nix secrets configuration is valid"
          exit 0
        else
          log_error "Found ${ISSUES} issue(s) with secrets configuration"
          log_info "Run 'task nix:secrets:init' to fix"
          exit 1
        fi

  refresh:
    desc: Apply the system configuration and switch to new generation
    silent: true
    deps: [update, clean-results]
    cmds:
      - |
        #!/usr/bin/env bash
        set -euo pipefail
        source {{.LOGLIB_PATH}}

        log_info "Applying system configuration"
        if ! NIXPKGS_ALLOW_UNFREE={{.NIXPKGS_ALLOW_UNFREE}} sudo -E {{.NIX_DARWIN_REBUILD}} switch --flake . --impure; then
          log_error "Refresh failed (see logs above)"
          exit {{.ERROR_EXIT_CODE}}
        fi

        log_success "System configuration applied successfully"
      - task: clean-results
