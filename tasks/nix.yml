# yaml-language-server: $schema=https://taskfile.dev/schema.json
version: "3"

tasks:
  clean-results:
    desc: Clean up result symlinks (internal helper)
    internal: true
    cmds:
      - sudo rm -f result result-* 2>/dev/null || true
    silent: true

  build:lv426:
    desc: Build lv426 (macOS) system configuration
    silent: true
    deps: [clean-results]
    cmds:
      - |
        #!/usr/bin/env nu
        print "Building lv426 configuration"
        try {
          env NIXPKGS_ALLOW_UNFREE={{.NIXPKGS_ALLOW_UNFREE}} nix build .#darwinConfigurations.lv426.system
          print "✓ lv426 build completed successfully"
        } catch {
          print "✗ lv426 build failed"
          exit 1
        }
      - task: clean-results

  build:arrakis:
    desc: Build arrakis (NixOS) system configuration
    silent: true
    deps: [clean-results]
    cmds:
      - |
        #!/usr/bin/env nu
        print "Building arrakis configuration"
        try {
          env NIXPKGS_ALLOW_UNFREE={{.NIXPKGS_ALLOW_UNFREE}} nix build .#nixosConfigurations.arrakis.config.system.build.toplevel
          print "✓ arrakis build completed successfully"
        } catch {
          print "✗ arrakis build failed"
          exit 1
        }
      - task: clean-results

  refresh:lv426:
    desc: Apply lv426 (macOS) system configuration
    silent: true
    deps: [clean-results]
    cmds:
      - |
        #!/usr/bin/env nu
        print "Applying lv426 system configuration"
        try {
          env NIXPKGS_ALLOW_UNFREE={{.NIXPKGS_ALLOW_UNFREE}} sudo -E {{.NIX_DARWIN_REBUILD}} switch --flake .#lv426 --impure
          print "✓ lv426 system configuration applied successfully"
        } catch {
          print "✗ lv426 refresh failed (see logs above)"
          exit 1
        }
      - task: clean-results

  refresh:arrakis:
    desc: Apply arrakis (NixOS) system configuration
    silent: true
    deps: [clean-results]
    cmds:
      - |
        #!/usr/bin/env nu
        print "Applying arrakis system configuration"
        try {
          env NIXPKGS_ALLOW_UNFREE={{.NIXPKGS_ALLOW_UNFREE}} sudo nixos-rebuild switch --flake .#arrakis
          print "✓ arrakis system configuration applied successfully"
        } catch {
          print "✗ arrakis refresh failed (see logs above)"
          exit 1
        }
      - task: clean-results

  refresh:work:
    desc: Apply work system configuration (builds and applies in work repo)
    silent: true
    cmds:
      - |
        #!/usr/bin/env nu
        let work_sysinit = (find {{.WORK_REPO_PATH}} -type d -name "sysinit" -maxdepth 2 | head -n 1)
        
        if ($work_sysinit | is-empty) {
          print "Could not find work sysinit repository in {{.WORK_REPO_PATH}}"
          exit 1
        }
        
        print $"Refreshing work configuration at: ($work_sysinit)"
        try {
          cd $work_sysinit
          env NIX_MAX_JOBS=1 NIX_CORES=1 task nix:refresh:work
        } catch {
          print "✗ Work refresh failed"
          exit 1
        }

  build:work:
    desc: Build work system configuration (builds in work repo with reduced resources)
    silent: true
    cmds:
      - |
        #!/usr/bin/env nu
        let work_sysinit = (find {{.WORK_REPO_PATH}} -type d -name "sysinit" -maxdepth 2 | head -n 1)
        
        if ($work_sysinit | is-empty) {
          print "Could not find work sysinit repository in {{.WORK_REPO_PATH}}"
          exit 1
        }
        
        try {
          cd $work_sysinit
          env NIX_MAX_JOBS=1 NIX_CORES=1 task build:work
        } catch {
          print "✗ Work build failed"
          exit 1
        }

  clean:
    desc: Clean Nix store and delete old generations
    silent: true
    deps: [clean-results]
    cmds:
      - |
        #!/usr/bin/env nu
        print "Collecting garbage"
        try {
          ^nix-collect-garbage
          print "✓ Nix store cleaned and optimized"
        } catch {
          print "✗ Failed to collect garbage"
          exit 1
        }

  update:
    desc: Update Nix flake inputs and commit lock file
    silent: true
    cmds:
      - |
        #!/usr/bin/env nu
        print "Updating nix flake inputs"
        try {
          ^nix flake update
          
          if (^git diff --quiet flake.lock) {
            print "No changes to flake.lock"
          } else {
            ^git add flake.lock
            ^git commit -m "flake.lock: Update"
            print "Committed flake.lock changes"
          }
          
          print "✓ Flake inputs updated successfully"
        } catch {
          print "✗ Flake update failed (see logs above)"
          exit 1
        }

  config:
    desc: Copy nix configs (custom and secrets) to /etc/nix/ with sudo
    silent: true
    cmds:
      - |
        #!/usr/bin/env nu
        print "Updating nix configuration"
        
        try {
          # Copy custom config
          ^sudo cp nix.custom.conf /etc/nix/nix.custom.conf
          
          # Copy secrets if they exist
          if (("nix.secrets.conf" | path exists)) {
            ^sudo cp nix.secrets.conf /etc/nix/nix.secrets.conf
            ^sudo chmod 600 /etc/nix/nix.secrets.conf
            print "Deployed nix.secrets.conf with restrictive permissions"
          } else {
            print "nix.secrets.conf not found (run 'task nix:secrets:init' to create)"
          }
          
          print "✓ Nix configuration updated successfully"
          print "Run 'sudo launchctl stop org.nixos.nix-daemon && sleep 2 && sudo launchctl start org.nixos.nix-daemon' to restart daemon with new config"
        } catch {
          print "✗ Failed to update nix configuration"
          exit 1
        }

  config:user:
    desc: Setup user-level nix.conf to include system nix.custom.conf
    silent: true
    cmds:
      - |
        #!/usr/bin/env nu
        let nix_config_dir = ($"($env.HOME)/.config/nix")
        let nix_config = ($"($nix_config_dir)/nix.conf")
        let system_custom_conf = "/etc/nix/nix.custom.conf"
        
        print "Setting up user-level nix.conf"
        
        try {
          mkdir -p $nix_config_dir
          
          let config_lines = [
            "# User-level Nix configuration",
            "# Includes system-wide configuration from /etc/nix/",
            "",
            "# Enable Nix 2.0 features",
            "experimental-features = nix-command flakes auto-allocate-uids impure-derivations dynamic-derivations",
            "",
            "# Trust current user for operations",
            $"trusted-users = root ($env.USER)",
            "",
            "# Include system-wide configuration (caches, substituters, secrets)",
            $"!include ($system_custom_conf)"
          ]
          
          ($config_lines | str join "\n") | save --force $nix_config
          
          print $"✓ User nix.conf configured at ($nix_config)"
          print "Access tokens from nix.secrets.conf will now be loaded when nix runs"
        } catch {
          print "✗ Failed to setup user nix.conf"
          exit 1
        }

  secrets:init:
    desc: Initialize nix.secrets.conf with GitHub token (automatic, idempotent)
    silent: true
    cmds:
      - |
        #!/usr/bin/env nu
        let secrets_file = "{{.ROOT_DIR}}/nix.secrets.conf"
        let system_secrets_file = "{{.NIX_SYSTEM_CONF_DIR}}/nix.secrets.conf"
        
        def is_secrets_file_valid [file] {
          ($file | path exists) and (open $file | grep -q '^[^#]*access-tokens[[:space:]]*=')
        }
        
        def create_secrets_file [token] {
          let content = $"# Nix secrets configuration\n# GitHub Personal Access Token for private repository access\naccess-tokens = github.com=($token)"
          $content | save --force $secrets_file
          chmod 600 $secrets_file
        }
        
        def deploy_secrets [] {
          print $"Deploying secrets to ($system_secrets_file)"
          try {
            ^sudo cp $secrets_file $system_secrets_file
            ^sudo chmod 600 $system_secrets_file
            print "To apply new secrets, restart nix-daemon:"
            print "sudo launchctl stop org.nixos.nix-daemon && sleep 2 && sudo launchctl start org.nixos.nix-daemon"
            true
          } catch {
            print "Failed to copy secrets to system directory"
            false
          }
        }
        
        print "Initializing nix secrets configuration"
        
        if (is_secrets_file_valid $secrets_file) {
          print "Valid nix.secrets.conf already exists"
          
          # Check system deployment
          try {
            let sys_has_tokens = (^sudo grep -q '^[^#]*access-tokens[[:space:]]*=' $system_secrets_file)
            if not ($system_secrets_file | path exists) or (not ($sys_has_tokens)) {
              if (deploy_secrets) {
                print "Secrets deployed to system"
              }
            } else {
              print "Secrets already deployed to system"
            }
          } catch {
            if (deploy_secrets) {
              print "Secrets deployed to system"
            }
          }
          exit 0
        }
        
        # Try to get token from gh CLI
        print "Attempting to get GitHub token from gh CLI"
        try {
          if (which gh | is-empty | not) {
            let token = (^gh auth token 2>/dev/null)
            if (($token | is-empty) | not) {
              print "Retrieved token from gh CLI"
              create_secrets_file $token
              
              if (deploy_secrets) {
                print "✓ Secrets initialized and deployed successfully"
                exit 0
              } else {
                exit 1
              }
            } else {
              print "gh CLI is installed but not authenticated"
              print "Run 'gh auth login' to authenticate, then re-run this task"
            }
          } else {
            print "gh CLI not found in PATH"
            print "Authenticate with gh CLI: gh auth login"
          }
        } catch {
          print "gh CLI check failed"
        }
        
        # If we get here, we couldn't auto-configure
        print "Could not automatically configure GitHub authentication"
        exit 0

  secrets:check:
    desc: Check if nix.secrets.conf exists and is properly configured
    silent: true
    cmds:
      - |
        #!/usr/bin/env nu
        let secrets_file = "{{.ROOT_DIR}}/nix.secrets.conf"
        let system_secrets_file = "{{.NIX_SYSTEM_CONF_DIR}}/nix.secrets.conf"
        
        def is_secrets_file_valid [file] {
          ($file | path exists) and (open $file | grep -q '^[^#]*access-tokens[[:space:]]*=')
        }
        
        print "Checking nix secrets configuration"
        mut issues = 0
        
        # Check repository file
        if not (is_secrets_file_valid $secrets_file) {
          print "nix.secrets.conf not found or invalid in repository root"
          $issues = $issues + 1
        } else {
          # Check permissions
          if ($secrets_file | path exists) {
            let perms = (stat -f "%Lp" $secrets_file 2>/dev/null)
            if $perms != "600" {
              print $"Incorrect permissions on nix.secrets.conf: ($perms) (should be 600)"
              $issues = $issues + 1
            }
          }
        }
        
        # Check system deployment
        try {
          let sys_exists = ($system_secrets_file | path exists)
          let sys_has_tokens = if $sys_exists {
            (^sudo grep -q '^[^#]*access-tokens[[:space:]]*=' $system_secrets_file) and true
          } else {
            false
          }
          
          if (not $sys_exists) or (not $sys_has_tokens) {
            print $"Secrets not deployed to ($system_secrets_file)"
            $issues = $issues + 1
          } else {
            let perms = (^sudo stat -f "%Lp" $system_secrets_file 2>/dev/null)
            if $perms != "600" {
              print $"Incorrect permissions on system secrets: ($perms) (should be 600)"
              $issues = $issues + 1
            }
          }
        } catch {
          print $"Secrets not deployed to ($system_secrets_file)"
          $issues = $issues + 1
        }
        
        # Check gh CLI auth status (informational only)
        try {
          if (which gh | is-empty | not) {
            if (^gh auth token >/dev/null 2>&1) {
              print "gh CLI is authenticated"
            } else {
              print "gh CLI is installed but not authenticated"
            }
          } else {
            print "gh CLI not found in PATH"
          }
        } catch {
          print "gh CLI not found in PATH"
        }
        
        # Report results
        if $issues == 0 {
          print "✓ Nix secrets configuration is valid"
          exit 0
        } else {
          print $"Found ($issues) issue(s) with secrets configuration"
          print "Run 'task nix:secrets:init' to fix"
          exit 1
        }

  validate:
    desc: Validate Nix configuration (format checks via flake check)
    silent: true
    cmds:
      - |
        #!/usr/bin/env nu
        print "Running Nix validation checks"
        
        try {
          ^nix flake check --no-build
          print "✓ Nix validation passed (format checks complete)"
        } catch {
          print "✗ Flake check failed (see logs above)"
          exit 1
        }
