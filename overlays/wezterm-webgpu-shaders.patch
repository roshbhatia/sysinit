From 401db5e93d5187188db0ea104f042c97d14ecb99 Mon Sep 17 00:00:00 2001
From: Joel Eriksson <je@clevcode.org>
Date: Mon, 5 Jan 2026 01:32:24 +0200
Subject: [PATCH] feat: add custom post-processing shader support for WebGPU
 backend
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

This adds the ability to apply custom WGSL shaders as post-processing
effects to the terminal output when using the WebGpu front-end.

New config options:
- `webgpu_shader`: Path to a WGSL shader file for post-processing
- `webgpu_shader_fps`: Frame rate for continuous shader animation
  (default 0/disabled, set to 60 for smooth animations)

The shader receives:
- The rendered terminal as a texture
- Screen resolution and elapsed time as uniforms

This enables effects like CRT simulation, bloom, scanlines, and more.
Example shaders are included in assets/shader-examples/.

Usage in wezterm.lua:
  config.front_end = "WebGpu"
  config.webgpu_shader = wezterm.config_dir .. "/my-shader.wgsl"

Closes #6985

ðŸ¤– Generated with [Claude Code](https://claude.com/claude-code)

Co-Authored-By: Claude Opus 4.5 <noreply@anthropic.com>
---
 assets/shader-examples/bloom.wgsl          |  81 ++++++++
 assets/shader-examples/digital-rain.wgsl   |  86 +++++++++
 assets/shader-examples/passthrough.wgsl    |  40 ++++
 assets/shader-examples/retro-crt.wgsl      | 128 +++++++++++++
 assets/shader-examples/scanlines.wgsl      |  59 ++++++
 assets/shader-examples/vignette.wgsl       |  39 ++++
 config/src/config.rs                       |  25 +++
 wezterm-gui/src/termwindow/mod.rs          |  21 ++
 wezterm-gui/src/termwindow/render/draw.rs  |  62 +++++-
 wezterm-gui/src/termwindow/render/paint.rs |  21 ++
 wezterm-gui/src/termwindow/webgpu.rs       | 211 +++++++++++++++++++++
 11 files changed, 770 insertions(+), 3 deletions(-)
 create mode 100644 assets/shader-examples/bloom.wgsl
 create mode 100644 assets/shader-examples/digital-rain.wgsl
 create mode 100644 assets/shader-examples/passthrough.wgsl
 create mode 100644 assets/shader-examples/retro-crt.wgsl
 create mode 100644 assets/shader-examples/scanlines.wgsl
 create mode 100644 assets/shader-examples/vignette.wgsl

diff --git a/assets/shader-examples/bloom.wgsl b/assets/shader-examples/bloom.wgsl
new file mode 100644
index 00000000000..f7a3ba01519
--- /dev/null
+++ b/assets/shader-examples/bloom.wgsl
@@ -0,0 +1,81 @@
+// Bloom/Glow Shader for WezTerm
+// Adds a soft glow effect to bright areas of the terminal
+//
+// Usage in wezterm.lua:
+//   config.front_end = "WebGpu"
+//   config.webgpu_shader = wezterm.config_dir .. "/bloom.wgsl"
+
+struct PostProcessUniform {
+    resolution: vec2<f32>,
+    time: f32,
+    _padding: f32,
+};
+
+@group(0) @binding(0) var<uniform> uniforms: PostProcessUniform;
+@group(0) @binding(1) var input_texture: texture_2d<f32>;
+@group(0) @binding(2) var input_sampler: sampler;
+
+struct VertexOutput {
+    @builtin(position) position: vec4<f32>,
+    @location(0) uv: vec2<f32>,
+};
+
+@vertex
+fn vs_main(@builtin(vertex_index) vertex_index: u32) -> VertexOutput {
+    var out: VertexOutput;
+    let x = f32(i32(vertex_index & 1u) * 4 - 1);
+    let y = f32(i32(vertex_index >> 1u) * 4 - 1);
+    out.position = vec4<f32>(x, y, 0.0, 1.0);
+    out.uv = vec2<f32>((x + 1.0) * 0.5, (1.0 - y) * 0.5);
+    return out;
+}
+
+// Get luminance of a color
+fn luminance(c: vec3<f32>) -> f32 {
+    return dot(c, vec3<f32>(0.299, 0.587, 0.114));
+}
+
+@fragment
+fn fs_main(in: VertexOutput) -> @location(0) vec4<f32> {
+    let pixel_size = 1.0 / uniforms.resolution;
+    let original = textureSample(input_texture, input_sampler, in.uv).rgb;
+
+    // Large blur kernel for visible glow (wider spread = 4-8 pixels)
+    // Center sample
+    var blurred = textureSample(input_texture, input_sampler, in.uv).rgb * 0.15;
+
+    // Inner ring (4 pixels away)
+    let r1 = 4.0;
+    blurred += textureSample(input_texture, input_sampler, in.uv + vec2<f32>(-r1, 0.0) * pixel_size).rgb * 0.1;
+    blurred += textureSample(input_texture, input_sampler, in.uv + vec2<f32>(r1, 0.0) * pixel_size).rgb * 0.1;
+    blurred += textureSample(input_texture, input_sampler, in.uv + vec2<f32>(0.0, -r1) * pixel_size).rgb * 0.1;
+    blurred += textureSample(input_texture, input_sampler, in.uv + vec2<f32>(0.0, r1) * pixel_size).rgb * 0.1;
+
+    // Outer ring (8 pixels away)
+    let r2 = 8.0;
+    blurred += textureSample(input_texture, input_sampler, in.uv + vec2<f32>(-r2, 0.0) * pixel_size).rgb * 0.06;
+    blurred += textureSample(input_texture, input_sampler, in.uv + vec2<f32>(r2, 0.0) * pixel_size).rgb * 0.06;
+    blurred += textureSample(input_texture, input_sampler, in.uv + vec2<f32>(0.0, -r2) * pixel_size).rgb * 0.06;
+    blurred += textureSample(input_texture, input_sampler, in.uv + vec2<f32>(0.0, r2) * pixel_size).rgb * 0.06;
+
+    // Diagonal samples
+    let d = 5.6;  // ~4*sqrt(2)
+    blurred += textureSample(input_texture, input_sampler, in.uv + vec2<f32>(-d, -d) * pixel_size).rgb * 0.04;
+    blurred += textureSample(input_texture, input_sampler, in.uv + vec2<f32>(d, -d) * pixel_size).rgb * 0.04;
+    blurred += textureSample(input_texture, input_sampler, in.uv + vec2<f32>(-d, d) * pixel_size).rgb * 0.04;
+    blurred += textureSample(input_texture, input_sampler, in.uv + vec2<f32>(d, d) * pixel_size).rgb * 0.04;
+
+    // Create bloom from bright areas - lower threshold for more visible effect
+    let lum = luminance(blurred);
+    let bloom_strength = smoothstep(0.1, 0.5, lum);
+    let bloom = blurred * bloom_strength * 1.5;
+
+    // Combine original with bloom - stronger effect
+    var col = original + bloom * 0.8;
+
+    // Slight saturation boost for that glowy feel
+    let gray = dot(col, vec3<f32>(0.299, 0.587, 0.114));
+    col = mix(vec3<f32>(gray), col, 1.2);
+
+    return vec4<f32>(col, 1.0);
+}
diff --git a/assets/shader-examples/digital-rain.wgsl b/assets/shader-examples/digital-rain.wgsl
new file mode 100644
index 00000000000..dba3928a1d9
--- /dev/null
+++ b/assets/shader-examples/digital-rain.wgsl
@@ -0,0 +1,86 @@
+// Digital Rain Shader for WezTerm
+// Matrix-style animated digital rain effect overlaid on terminal
+//
+// Usage in wezterm.lua:
+//   config.front_end = "WebGpu"
+//   config.webgpu_shader = wezterm.config_dir .. "/digital-rain.wgsl"
+
+struct PostProcessUniform {
+    resolution: vec2<f32>,
+    time: f32,
+    _padding: f32,
+};
+
+@group(0) @binding(0) var<uniform> uniforms: PostProcessUniform;
+@group(0) @binding(1) var input_texture: texture_2d<f32>;
+@group(0) @binding(2) var input_sampler: sampler;
+
+struct VertexOutput {
+    @builtin(position) position: vec4<f32>,
+    @location(0) uv: vec2<f32>,
+};
+
+@vertex
+fn vs_main(@builtin(vertex_index) vertex_index: u32) -> VertexOutput {
+    var out: VertexOutput;
+    let x = f32(i32(vertex_index & 1u) * 4 - 1);
+    let y = f32(i32(vertex_index >> 1u) * 4 - 1);
+    out.position = vec4<f32>(x, y, 0.0, 1.0);
+    out.uv = vec2<f32>((x + 1.0) * 0.5, (1.0 - y) * 0.5);
+    return out;
+}
+
+// Pseudo-random function
+fn rand(co: vec2<f32>) -> f32 {
+    return fract(sin(dot(co, vec2<f32>(12.9898, 78.233))) * 43758.5453);
+}
+
+// Create a single rain drop column
+fn rain_drop(uv: vec2<f32>, col_id: f32, speed: f32) -> f32 {
+    let time_offset = rand(vec2<f32>(col_id, 0.0)) * 10.0;
+    let drop_length = 0.1 + rand(vec2<f32>(col_id, 1.0)) * 0.15;
+
+    // Position of drop head (moving down)
+    let head_y = fract((uniforms.time * speed + time_offset) * 0.3);
+
+    // Distance from drop head
+    let dist_from_head = head_y - uv.y;
+
+    // Create trail effect (bright at head, fading behind)
+    if (dist_from_head > 0.0 && dist_from_head < drop_length) {
+        return (1.0 - dist_from_head / drop_length) * 0.3;
+    }
+
+    return 0.0;
+}
+
+@fragment
+fn fs_main(in: VertexOutput) -> @location(0) vec4<f32> {
+    var col = textureSample(input_texture, input_sampler, in.uv).rgb;
+
+    // Create rain effect
+    let num_columns = 80.0;
+    let col_width = 1.0 / num_columns;
+    let col_id = floor(in.uv.x * num_columns);
+
+    // Multiple rain layers at different speeds
+    var rain = 0.0;
+    rain += rain_drop(in.uv, col_id, 1.0) * step(0.7, rand(vec2<f32>(col_id, 2.0)));
+    rain += rain_drop(in.uv, col_id + 100.0, 0.7) * step(0.8, rand(vec2<f32>(col_id, 3.0)));
+    rain += rain_drop(in.uv, col_id + 200.0, 1.3) * step(0.75, rand(vec2<f32>(col_id, 4.0)));
+
+    // Add green tint from rain
+    let rain_color = vec3<f32>(0.0, rain, rain * 0.3);
+
+    // Slight green tint to the whole image
+    col = col * vec3<f32>(0.9, 1.0, 0.9);
+
+    // Combine with rain overlay
+    col = col + rain_color;
+
+    // Subtle scanlines
+    let scanline = sin(in.uv.y * uniforms.resolution.y * 3.14159) * 0.5 + 0.5;
+    col *= 0.95 + 0.05 * scanline;
+
+    return vec4<f32>(col, 1.0);
+}
diff --git a/assets/shader-examples/passthrough.wgsl b/assets/shader-examples/passthrough.wgsl
new file mode 100644
index 00000000000..a40c04f7e98
--- /dev/null
+++ b/assets/shader-examples/passthrough.wgsl
@@ -0,0 +1,40 @@
+// Default post-processing shader for WezTerm
+// This is a pass-through shader. Users can create their own custom
+// shaders with effects like CRT simulation, bloom, scanlines, etc.
+//
+// To use a custom shader, add to your wezterm config:
+//   config.front_end = "WebGpu"
+//   config.webgpu_shader = "/path/to/your/shader.wgsl"
+
+struct PostProcessUniform {
+    resolution: vec2<f32>,
+    time: f32,
+    _padding: f32,
+};
+
+@group(0) @binding(0) var<uniform> uniforms: PostProcessUniform;
+@group(0) @binding(1) var input_texture: texture_2d<f32>;
+@group(0) @binding(2) var input_sampler: sampler;
+
+struct VertexOutput {
+    @builtin(position) position: vec4<f32>,
+    @location(0) uv: vec2<f32>,
+};
+
+// Full-screen triangle vertices (no vertex buffer needed)
+@vertex
+fn vs_main(@builtin(vertex_index) vertex_index: u32) -> VertexOutput {
+    var out: VertexOutput;
+    // Generate a full-screen triangle covering the entire viewport
+    let x = f32(i32(vertex_index & 1u) * 4 - 1);
+    let y = f32(i32(vertex_index >> 1u) * 4 - 1);
+    out.position = vec4<f32>(x, y, 0.0, 1.0);
+    out.uv = vec2<f32>((x + 1.0) * 0.5, (1.0 - y) * 0.5);
+    return out;
+}
+
+// Default pass-through fragment shader
+@fragment
+fn fs_main(in: VertexOutput) -> @location(0) vec4<f32> {
+    return textureSample(input_texture, input_sampler, in.uv);
+}
diff --git a/assets/shader-examples/retro-crt.wgsl b/assets/shader-examples/retro-crt.wgsl
new file mode 100644
index 00000000000..30f51d7582d
--- /dev/null
+++ b/assets/shader-examples/retro-crt.wgsl
@@ -0,0 +1,128 @@
+// Retro CRT Shader for WezTerm
+// Inspired by 80s aesthetics, Tron, and Blade Runner
+//
+// Effects included:
+// - CRT screen curvature
+// - Scanlines
+// - Chromatic aberration
+// - Vignette
+// - Subtle bloom/glow
+// - Film grain
+// - Color grading (cyan/magenta push)
+//
+// Usage in wezterm.lua:
+//   config.front_end = "WebGpu"
+//   config.webgpu_shader = wezterm.config_dir .. "/retro-crt.wgsl"
+
+struct PostProcessUniform {
+    resolution: vec2<f32>,
+    time: f32,
+    _padding: f32,
+};
+
+@group(0) @binding(0) var<uniform> uniforms: PostProcessUniform;
+@group(0) @binding(1) var input_texture: texture_2d<f32>;
+@group(0) @binding(2) var input_sampler: sampler;
+
+struct VertexOutput {
+    @builtin(position) position: vec4<f32>,
+    @location(0) uv: vec2<f32>,
+};
+
+@vertex
+fn vs_main(@builtin(vertex_index) vertex_index: u32) -> VertexOutput {
+    var out: VertexOutput;
+    let x = f32(i32(vertex_index & 1u) * 4 - 1);
+    let y = f32(i32(vertex_index >> 1u) * 4 - 1);
+    out.position = vec4<f32>(x, y, 0.0, 1.0);
+    out.uv = vec2<f32>((x + 1.0) * 0.5, (1.0 - y) * 0.5);
+    return out;
+}
+
+// CRT screen curvature
+fn crt_curve(uv: vec2<f32>, curvature: f32) -> vec2<f32> {
+    let center = uv - 0.5;
+    let dist = dot(center, center) * curvature;
+    return uv + center * dist;
+}
+
+// Chromatic aberration - separates RGB channels
+fn chromatic_aberration(uv: vec2<f32>, intensity: f32) -> vec3<f32> {
+    let r = textureSample(input_texture, input_sampler, uv + vec2<f32>(intensity, 0.0)).r;
+    let g = textureSample(input_texture, input_sampler, uv).g;
+    let b = textureSample(input_texture, input_sampler, uv - vec2<f32>(intensity, 0.0)).b;
+    return vec3<f32>(r, g, b);
+}
+
+// Scanline effect - smoother to reduce moirÃ©
+fn scanline(y: f32, intensity: f32) -> f32 {
+    let line = sin(y * uniforms.resolution.y * 3.14159 / 3.0);
+    return 1.0 - intensity * (0.5 + 0.5 * line);
+}
+
+// Vignette - darkens edges (same as vignette.wgsl)
+fn vignette(uv: vec2<f32>) -> f32 {
+    let center = uv - 0.5;
+    return 1.0 - dot(center, center) * 1.2;
+}
+
+// Simple pseudo-random for grain
+fn rand(co: vec2<f32>) -> f32 {
+    return fract(sin(dot(co, vec2<f32>(12.9898, 78.233))) * 43758.5453);
+}
+
+// Approximate bloom by sampling nearby pixels
+fn bloom(uv: vec2<f32>, intensity: f32) -> vec3<f32> {
+    var col = vec3<f32>(0.0);
+    let pixel_size = 1.0 / uniforms.resolution;
+
+    for (var x: f32 = -2.0; x <= 2.0; x += 1.0) {
+        for (var y: f32 = -2.0; y <= 2.0; y += 1.0) {
+            let offset = vec2<f32>(x, y) * pixel_size * 2.0;
+            col += textureSample(input_texture, input_sampler, uv + offset).rgb;
+        }
+    }
+    return col / 25.0 * intensity;
+}
+
+@fragment
+fn fs_main(in: VertexOutput) -> @location(0) vec4<f32> {
+    // Apply CRT curvature (subtle)
+    let uv = crt_curve(in.uv, 0.05);
+
+    // Check if outside the curved screen
+    if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) {
+        return vec4<f32>(0.0, 0.0, 0.0, 1.0);
+    }
+
+    // Chromatic aberration
+    var col = chromatic_aberration(uv, 0.001);
+
+    // Add bloom for neon glow effect
+    let glow = bloom(uv, 1.2);
+    col = mix(col, glow, 0.15);
+
+    // Boost cyans and magentas (Tron palette)
+    col.r *= 1.0 + 0.08 * col.b;
+    col.b *= 1.1;
+    col.g *= 0.95 + 0.1 * col.b;
+
+    // Scanlines (subtle)
+    col *= scanline(uv.y, 0.15);
+
+    // Subtle horizontal line flicker
+    let flicker = 1.0 + 0.01 * sin(uniforms.time * 10.0 + uv.y * 100.0);
+    col *= flicker;
+
+    // Vignette
+    col *= vignette(uv);
+
+    // Color grade - push toward blue/cyan shadows
+    col = mix(col, col * vec3<f32>(0.9, 0.95, 1.1), 0.3);
+
+    // Film grain
+    let grain = rand(uv + fract(uniforms.time));
+    col += (grain - 0.5) * 0.03;
+
+    return vec4<f32>(col, 1.0);
+}
diff --git a/assets/shader-examples/scanlines.wgsl b/assets/shader-examples/scanlines.wgsl
new file mode 100644
index 00000000000..d911294b6a3
--- /dev/null
+++ b/assets/shader-examples/scanlines.wgsl
@@ -0,0 +1,59 @@
+// Scanlines Shader for WezTerm
+// CRT-style horizontal scanlines effect
+//
+// Usage in wezterm.lua:
+//   config.front_end = "WebGpu"
+//   config.webgpu_shader = wezterm.config_dir .. "/scanlines.wgsl"
+
+struct PostProcessUniform {
+    resolution: vec2<f32>,
+    time: f32,
+    _padding: f32,
+};
+
+@group(0) @binding(0) var<uniform> uniforms: PostProcessUniform;
+@group(0) @binding(1) var input_texture: texture_2d<f32>;
+@group(0) @binding(2) var input_sampler: sampler;
+
+struct VertexOutput {
+    @builtin(position) position: vec4<f32>,
+    @location(0) uv: vec2<f32>,
+};
+
+@vertex
+fn vs_main(@builtin(vertex_index) vertex_index: u32) -> VertexOutput {
+    var out: VertexOutput;
+    let x = f32(i32(vertex_index & 1u) * 4 - 1);
+    let y = f32(i32(vertex_index >> 1u) * 4 - 1);
+    out.position = vec4<f32>(x, y, 0.0, 1.0);
+    out.uv = vec2<f32>((x + 1.0) * 0.5, (1.0 - y) * 0.5);
+    return out;
+}
+
+@fragment
+fn fs_main(in: VertexOutput) -> @location(0) vec4<f32> {
+    // Slight RGB separation for CRT feel (chromatic aberration)
+    let offset = 0.0015;
+    let r = textureSample(input_texture, input_sampler, in.uv + vec2<f32>(offset, 0.0)).r;
+    let g = textureSample(input_texture, input_sampler, in.uv).g;
+    let b = textureSample(input_texture, input_sampler, in.uv - vec2<f32>(offset, 0.0)).b;
+    var col = vec3<f32>(r, g, b);
+
+    // Calculate scanline effect - every 3 pixels
+    let y_pixel = in.uv.y * uniforms.resolution.y;
+    let scanline_period = 3.0;
+    let scanline = sin(y_pixel * 3.14159 / scanline_period);
+
+    // Smooth scanlines: dark lines ~60% brightness, bright lines 100%
+    col *= 0.6 + 0.4 * (0.5 + 0.5 * scanline);
+
+    // Subtle vignette effect
+    let center = in.uv - 0.5;
+    let vignette = 1.0 - dot(center, center) * 0.5;
+    col *= vignette;
+
+    // Brightness boost to compensate for darkening
+    col *= 1.15;
+
+    return vec4<f32>(col, 1.0);
+}
diff --git a/assets/shader-examples/vignette.wgsl b/assets/shader-examples/vignette.wgsl
new file mode 100644
index 00000000000..84d7b9050ba
--- /dev/null
+++ b/assets/shader-examples/vignette.wgsl
@@ -0,0 +1,39 @@
+// Vignette Shader for WezTerm
+// Darkens the edges of the screen for a focused/cinematic look
+
+struct PostProcessUniform {
+    resolution: vec2<f32>,
+    time: f32,
+    _padding: f32,
+};
+
+@group(0) @binding(0) var<uniform> uniforms: PostProcessUniform;
+@group(0) @binding(1) var input_texture: texture_2d<f32>;
+@group(0) @binding(2) var input_sampler: sampler;
+
+struct VertexOutput {
+    @builtin(position) position: vec4<f32>,
+    @location(0) uv: vec2<f32>,
+};
+
+@vertex
+fn vs_main(@builtin(vertex_index) vertex_index: u32) -> VertexOutput {
+    var out: VertexOutput;
+    let x = f32(i32(vertex_index & 1u) * 4 - 1);
+    let y = f32(i32(vertex_index >> 1u) * 4 - 1);
+    out.position = vec4<f32>(x, y, 0.0, 1.0);
+    out.uv = vec2<f32>((x + 1.0) * 0.5, (1.0 - y) * 0.5);
+    return out;
+}
+
+@fragment
+fn fs_main(in: VertexOutput) -> @location(0) vec4<f32> {
+    var col = textureSample(input_texture, input_sampler, in.uv).rgb;
+
+    // Vignette - darkens edges, bright in center
+    let center = in.uv - 0.5;
+    let vignette = 1.0 - dot(center, center) * 1.2;
+    col *= vignette;
+
+    return vec4<f32>(col, 1.0);
+}
diff --git a/config/src/config.rs b/config/src/config.rs
index 75afb97a1b3..01d87e1d42b 100644
--- a/config/src/config.rs
+++ b/config/src/config.rs
@@ -588,6 +588,21 @@ pub struct Config {
     #[dynamic(default = "default_one_point_oh")]
     pub window_background_opacity: f32,

+    /// Specifies the path to a WGSL shader file that will be used
+    /// for post-processing the terminal output. The shader receives
+    /// the rendered terminal as a texture and can apply effects like
+    /// CRT simulation, bloom, scanlines, etc.
+    /// Requires front_end = "WebGpu" to be set.
+    #[dynamic(default)]
+    pub webgpu_shader: Option<PathBuf>,
+
+    /// When a custom webgpu_shader is configured, this controls the
+    /// frame rate for continuous shader updates (for animated shaders).
+    /// Set to 0 to disable continuous rendering (only re-render on changes).
+    /// Default is 0 (disabled). Set to 60 for smooth animations.
+    #[dynamic(default = "default_webgpu_shader_fps")]
+    pub webgpu_shader_fps: u8,
+
     /// inactive_pane_hue, inactive_pane_saturation and
     /// inactive_pane_brightness allow for transforming the color
     /// of inactive panes.
@@ -1329,6 +1344,12 @@ impl Config {
                     cfg.window_background_image.replace(config_dir.join(path));
                 }
             }
+
+            if let Some(path) = &self.webgpu_shader {
+                if !path.is_absolute() {
+                    cfg.webgpu_shader.replace(config_dir.join(path));
+                }
+            }
         }

         // Add some reasonable default font rules
@@ -1802,6 +1823,10 @@ fn default_anim_fps() -> u8 {
     10
 }

+fn default_webgpu_shader_fps() -> u8 {
+    0
+}
+
 fn default_max_fps() -> u64 {
     60
 }
diff --git a/wezterm-gui/src/termwindow/mod.rs b/wezterm-gui/src/termwindow/mod.rs
index 350cb8fb7ed..040961e6fab 100644
--- a/wezterm-gui/src/termwindow/mod.rs
+++ b/wezterm-gui/src/termwindow/mod.rs
@@ -879,6 +879,27 @@ impl TermWindow {
                 myself.created(RenderContext::Glium(Rc::clone(&gl)))?;
             }
             if let Some(webgpu) = webgpu {
+                // Load custom post-processing shader if configured
+                if let Some(shader_path) = &config.webgpu_shader {
+                    match std::fs::read_to_string(shader_path) {
+                        Ok(shader_source) => {
+                            if let Err(e) = webgpu.load_postprocess_shader(&shader_source) {
+                                log::error!(
+                                    "Failed to load WebGPU shader from {:?}: {}",
+                                    shader_path,
+                                    e
+                                );
+                            }
+                        }
+                        Err(e) => {
+                            log::error!(
+                                "Failed to read WebGPU shader file {:?}: {}",
+                                shader_path,
+                                e
+                            );
+                        }
+                    }
+                }
                 myself.webgpu.replace(Rc::clone(&webgpu));
                 myself.created(RenderContext::WebGpu(Rc::clone(&webgpu)))?;
             }
diff --git a/wezterm-gui/src/termwindow/render/draw.rs b/wezterm-gui/src/termwindow/render/draw.rs
index e190b6508f9..84d482b437a 100644
--- a/wezterm-gui/src/termwindow/render/draw.rs
+++ b/wezterm-gui/src/termwindow/render/draw.rs
@@ -1,5 +1,5 @@
 use crate::colorease::ColorEaseUniform;
-use crate::termwindow::webgpu::ShaderUniform;
+use crate::termwindow::webgpu::{PostProcessUniform, ShaderUniform};
 use crate::termwindow::RenderFrame;
 use crate::uniforms::UniformBuilder;
 use ::window::glium;
@@ -23,10 +23,35 @@ impl crate::TermWindow {
         let webgpu = self.webgpu.as_mut().unwrap();
         let render_state = self.render_state.as_ref().unwrap();

+        let has_postprocess = webgpu.has_postprocess();
+        let width = self.dimensions.pixel_width as u32;
+        let height = self.dimensions.pixel_height as u32;
+
+        log::trace!("call_draw_webgpu: has_postprocess={}", has_postprocess);
+
+        // Ensure intermediate texture exists if post-processing is enabled
+        if has_postprocess {
+            log::trace!("Creating intermediate texture {}x{}", width, height);
+            webgpu.ensure_intermediate_texture(width, height);
+        }
+
         let output = webgpu.surface.get_current_texture()?;
-        let view = output
+        let surface_view = output
             .texture
             .create_view(&wgpu::TextureViewDescriptor::default());
+
+        // Choose render target: intermediate texture if post-processing, otherwise surface
+        let intermediate_texture = webgpu.postprocess_intermediate_texture.borrow();
+        let render_target_view = if has_postprocess {
+            intermediate_texture
+                .as_ref()
+                .unwrap()
+                .create_view(&wgpu::TextureViewDescriptor::default())
+        } else {
+            surface_view.clone()
+        };
+        drop(intermediate_texture);
+
         let mut encoder = webgpu
             .device
             .create_command_encoder(&wgpu::CommandEncoderDescriptor {
@@ -87,6 +112,7 @@ impl crate::TermWindow {
         )
         .to_arrays_transposed();

+        // First pass: render terminal content to render target
         for layer in render_state.layers.borrow().iter() {
             for idx in 0..3 {
                 let vb = &layer.vb.borrow()[idx];
@@ -98,7 +124,7 @@ impl crate::TermWindow {
                     let mut render_pass = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
                         label: Some("Render Pass"),
                         color_attachments: &[Some(wgpu::RenderPassColorAttachment {
-                            view: &view,
+                            view: &render_target_view,
                             resolve_target: None,
                             ops: wgpu::Operations {
                                 load: if cleared {
@@ -142,6 +168,36 @@ impl crate::TermWindow {
             }
         }

+        // Second pass: apply post-processing shader if enabled
+        if has_postprocess {
+            let postprocess_uniform = webgpu.create_postprocess_uniform(PostProcessUniform {
+                resolution: [width as f32, height as f32],
+                time: self.created.elapsed().as_secs_f32(),
+                _padding: 0.0,
+            });
+
+            let pipeline = webgpu.postprocess_pipeline.borrow();
+            let mut render_pass = encoder.begin_render_pass(&wgpu::RenderPassDescriptor {
+                label: Some("PostProcess Pass"),
+                color_attachments: &[Some(wgpu::RenderPassColorAttachment {
+                    view: &surface_view,
+                    resolve_target: None,
+                    ops: wgpu::Operations {
+                        load: wgpu::LoadOp::Clear(wgpu::Color::BLACK),
+                        store: wgpu::StoreOp::Store,
+                    },
+                })],
+                depth_stencil_attachment: None,
+                occlusion_query_set: None,
+                timestamp_writes: None,
+            });
+
+            render_pass.set_pipeline(pipeline.as_ref().unwrap());
+            render_pass.set_bind_group(0, &postprocess_uniform, &[]);
+            // Draw a full-screen triangle (3 vertices, no vertex buffer needed)
+            render_pass.draw(0..3, 0..1);
+        }
+
         // submit will accept anything that implements IntoIter
         webgpu.queue.submit(std::iter::once(encoder.finish()));
         output.present();
diff --git a/wezterm-gui/src/termwindow/render/paint.rs b/wezterm-gui/src/termwindow/render/paint.rs
index 5218d2d77ed..e9ec968d7e5 100644
--- a/wezterm-gui/src/termwindow/render/paint.rs
+++ b/wezterm-gui/src/termwindow/render/paint.rs
@@ -115,6 +115,27 @@ impl crate::TermWindow {
         metrics::histogram!("gui.paint.impl").record(self.last_frame_duration);
         metrics::histogram!("gui.paint.impl.rate").record(1.);

+        // Schedule continuous rendering for animated shaders
+        if let Some(ref webgpu) = self.webgpu {
+            if webgpu.has_postprocess() {
+                let fps = self.config.webgpu_shader_fps;
+                if fps > 0 {
+                    let frame_interval = Duration::from_millis(1000 / fps as u64);
+                    let next_frame = Instant::now() + frame_interval;
+                    let mut has_anim = self.has_animation.borrow_mut();
+                    match *has_anim {
+                        None => {
+                            *has_anim = Some(next_frame);
+                        }
+                        Some(existing) if next_frame < existing => {
+                            *has_anim = Some(next_frame);
+                        }
+                        _ => {}
+                    }
+                }
+            }
+        }
+
         // If self.has_animation is some, then the last render detected
         // image attachments with multiple frames, so we also need to
         // invalidate the viewport when the next frame is due
diff --git a/wezterm-gui/src/termwindow/webgpu.rs b/wezterm-gui/src/termwindow/webgpu.rs
index 0be54acc72a..b10e4bb9151 100644
--- a/wezterm-gui/src/termwindow/webgpu.rs
+++ b/wezterm-gui/src/termwindow/webgpu.rs
@@ -21,6 +21,14 @@ pub struct ShaderUniform {
     // sampler2D atlas_linear_sampler;
 }

+#[repr(C)]
+#[derive(Copy, Clone, Default, Debug, bytemuck::Pod, bytemuck::Zeroable)]
+pub struct PostProcessUniform {
+    pub resolution: [f32; 2],
+    pub time: f32,
+    pub _padding: f32,
+}
+
 pub struct WebGpuState {
     pub adapter_info: wgpu::AdapterInfo,
     pub downlevel_caps: wgpu::DownlevelCapabilities,
@@ -35,6 +43,11 @@ pub struct WebGpuState {
     pub texture_nearest_sampler: wgpu::Sampler,
     pub texture_linear_sampler: wgpu::Sampler,
     pub handle: RawHandlePair,
+    // Post-processing support
+    pub postprocess_pipeline: RefCell<Option<wgpu::RenderPipeline>>,
+    pub postprocess_bind_group_layout: RefCell<Option<wgpu::BindGroupLayout>>,
+    pub postprocess_intermediate_texture: RefCell<Option<wgpu::Texture>>,
+    pub postprocess_sampler: wgpu::Sampler,
 }

 pub struct RawHandlePair {
@@ -492,6 +505,17 @@ impl WebGpuState {
             cache: None,
         });

+        // Create post-processing sampler
+        let postprocess_sampler = device.create_sampler(&wgpu::SamplerDescriptor {
+            address_mode_u: wgpu::AddressMode::ClampToEdge,
+            address_mode_v: wgpu::AddressMode::ClampToEdge,
+            address_mode_w: wgpu::AddressMode::ClampToEdge,
+            mag_filter: wgpu::FilterMode::Linear,
+            min_filter: wgpu::FilterMode::Linear,
+            mipmap_filter: wgpu::FilterMode::Linear,
+            ..Default::default()
+        });
+
         Ok(Self {
             adapter_info,
             downlevel_caps,
@@ -506,6 +530,10 @@ impl WebGpuState {
             texture_bind_group_layout,
             texture_nearest_sampler,
             texture_linear_sampler,
+            postprocess_pipeline: RefCell::new(None),
+            postprocess_bind_group_layout: RefCell::new(None),
+            postprocess_intermediate_texture: RefCell::new(None),
+            postprocess_sampler,
         })
     }

@@ -527,6 +555,69 @@ impl WebGpuState {
         })
     }

+    pub fn create_postprocess_uniform(&self, uniform: PostProcessUniform) -> wgpu::BindGroup {
+        let buffer = self
+            .device
+            .create_buffer_init(&wgpu::util::BufferInitDescriptor {
+                label: Some("PostProcess Uniform Buffer"),
+                contents: bytemuck::cast_slice(&[uniform]),
+                usage: wgpu::BufferUsages::UNIFORM | wgpu::BufferUsages::COPY_DST,
+            });
+
+        let intermediate_texture = self.postprocess_intermediate_texture.borrow();
+        let texture = intermediate_texture.as_ref().expect("intermediate texture must exist");
+        let texture_view = texture.create_view(&wgpu::TextureViewDescriptor::default());
+
+        let bind_group_layout = self.postprocess_bind_group_layout.borrow();
+        self.device.create_bind_group(&wgpu::BindGroupDescriptor {
+            layout: bind_group_layout.as_ref().unwrap(),
+            entries: &[
+                wgpu::BindGroupEntry {
+                    binding: 0,
+                    resource: buffer.as_entire_binding(),
+                },
+                wgpu::BindGroupEntry {
+                    binding: 1,
+                    resource: wgpu::BindingResource::TextureView(&texture_view),
+                },
+                wgpu::BindGroupEntry {
+                    binding: 2,
+                    resource: wgpu::BindingResource::Sampler(&self.postprocess_sampler),
+                },
+            ],
+            label: Some("PostProcess Bind Group"),
+        })
+    }
+
+    pub fn ensure_intermediate_texture(&self, width: u32, height: u32) {
+        let needs_recreate = {
+            let tex = self.postprocess_intermediate_texture.borrow();
+            match tex.as_ref() {
+                None => true,
+                Some(t) => t.width() != width || t.height() != height,
+            }
+        };
+
+        if needs_recreate && width > 0 && height > 0 {
+            let format = self.config.borrow().format;
+            let texture = self.device.create_texture(&wgpu::TextureDescriptor {
+                label: Some("PostProcess Intermediate Texture"),
+                size: wgpu::Extent3d {
+                    width,
+                    height,
+                    depth_or_array_layers: 1,
+                },
+                mip_level_count: 1,
+                sample_count: 1,
+                dimension: wgpu::TextureDimension::D2,
+                format,
+                usage: wgpu::TextureUsages::RENDER_ATTACHMENT | wgpu::TextureUsages::TEXTURE_BINDING,
+                view_formats: &[],
+            });
+            *self.postprocess_intermediate_texture.borrow_mut() = Some(texture);
+        }
+    }
+
     #[allow(unused_mut)]
     pub fn resize(&self, mut dims: Dimensions) {
         // During a live resize on Windows, the Dimensions that we're processing may be
@@ -558,4 +649,124 @@ impl WebGpuState {
             self.surface.configure(&self.device, &config);
         }
     }
+
+    /// Load a custom post-processing shader from the given WGSL source code
+    pub fn load_postprocess_shader(&self, shader_source: &str) -> anyhow::Result<()> {
+        // wgpu will validate and log any shader errors
+        // Using catch_unwind to prevent panics from crashing the terminal
+        let shader_result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
+            self.device.create_shader_module(wgpu::ShaderModuleDescriptor {
+                label: Some("Custom PostProcess Shader"),
+                source: wgpu::ShaderSource::Wgsl(shader_source.into()),
+            })
+        }));
+
+        let shader = match shader_result {
+            Ok(s) => s,
+            Err(e) => {
+                let msg = if let Some(s) = e.downcast_ref::<&str>() {
+                    s.to_string()
+                } else if let Some(s) = e.downcast_ref::<String>() {
+                    s.clone()
+                } else {
+                    "Unknown shader compilation error".to_string()
+                };
+                log::error!("WebGPU shader compilation failed: {}", msg);
+                return Err(anyhow!("Shader compilation failed: {}", msg));
+            }
+        };
+
+        // Create bind group layout for post-processing
+        let bind_group_layout = self.device.create_bind_group_layout(&wgpu::BindGroupLayoutDescriptor {
+            label: Some("PostProcess Bind Group Layout"),
+            entries: &[
+                // Uniform buffer
+                wgpu::BindGroupLayoutEntry {
+                    binding: 0,
+                    visibility: wgpu::ShaderStages::VERTEX | wgpu::ShaderStages::FRAGMENT,
+                    ty: wgpu::BindingType::Buffer {
+                        ty: wgpu::BufferBindingType::Uniform,
+                        has_dynamic_offset: false,
+                        min_binding_size: None,
+                    },
+                    count: None,
+                },
+                // Input texture
+                wgpu::BindGroupLayoutEntry {
+                    binding: 1,
+                    visibility: wgpu::ShaderStages::FRAGMENT,
+                    ty: wgpu::BindingType::Texture {
+                        multisampled: false,
+                        view_dimension: wgpu::TextureViewDimension::D2,
+                        sample_type: wgpu::TextureSampleType::Float { filterable: true },
+                    },
+                    count: None,
+                },
+                // Sampler
+                wgpu::BindGroupLayoutEntry {
+                    binding: 2,
+                    visibility: wgpu::ShaderStages::FRAGMENT,
+                    ty: wgpu::BindingType::Sampler(wgpu::SamplerBindingType::Filtering),
+                    count: None,
+                },
+            ],
+        });
+
+        let pipeline_layout = self.device.create_pipeline_layout(&wgpu::PipelineLayoutDescriptor {
+            label: Some("PostProcess Pipeline Layout"),
+            bind_group_layouts: &[&bind_group_layout],
+            push_constant_ranges: &[],
+        });
+
+        let format = self.config.borrow().format;
+
+        let pipeline = self.device.create_render_pipeline(&wgpu::RenderPipelineDescriptor {
+            label: Some("PostProcess Pipeline"),
+            layout: Some(&pipeline_layout),
+            vertex: wgpu::VertexState {
+                module: &shader,
+                entry_point: Some("vs_main"),
+                buffers: &[], // Full-screen triangle doesn't need vertex buffers
+                compilation_options: wgpu::PipelineCompilationOptions::default(),
+            },
+            fragment: Some(wgpu::FragmentState {
+                module: &shader,
+                entry_point: Some("fs_main"),
+                targets: &[Some(wgpu::ColorTargetState {
+                    format,
+                    blend: Some(wgpu::BlendState::REPLACE),
+                    write_mask: wgpu::ColorWrites::ALL,
+                })],
+                compilation_options: wgpu::PipelineCompilationOptions::default(),
+            }),
+            primitive: wgpu::PrimitiveState {
+                topology: wgpu::PrimitiveTopology::TriangleList,
+                strip_index_format: None,
+                front_face: wgpu::FrontFace::Ccw,
+                cull_mode: None,
+                polygon_mode: wgpu::PolygonMode::Fill,
+                unclipped_depth: false,
+                conservative: false,
+            },
+            depth_stencil: None,
+            multisample: wgpu::MultisampleState {
+                count: 1,
+                mask: !0,
+                alpha_to_coverage_enabled: false,
+            },
+            multiview: None,
+            cache: None,
+        });
+
+        *self.postprocess_bind_group_layout.borrow_mut() = Some(bind_group_layout);
+        *self.postprocess_pipeline.borrow_mut() = Some(pipeline);
+
+        log::info!("Loaded custom post-processing shader");
+        Ok(())
+    }
+
+    /// Check if post-processing is enabled
+    pub fn has_postprocess(&self) -> bool {
+        self.postprocess_pipeline.borrow().is_some()
+    }
 }
